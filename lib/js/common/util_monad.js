// Generated by BUCKLESCRIPT VERSION 1.7.5, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var Util_kernel = require("./util_kernel.js");

function Monad_make(M) {
  var $great$great = function (a, b) {
    return Curry._2(M[/* >>= */0], a, (function () {
                  return b;
                }));
  };
  var $eq$less$less = function (f, v) {
    return Curry._2(M[/* >>= */0], v, f);
  };
  var map = function (f, mx) {
    return Curry._2(M[/* >>= */0], mx, (function (x) {
                  return Curry._1(M[/* pure */1], Curry._1(f, x));
                }));
  };
  var ap = function (mf, mx) {
    return Curry._2(M[/* >>= */0], mf, (function (param) {
                  return Util_kernel.flip(map, mx, param);
                }));
  };
  var sequence = function (l) {
    var k = function (m, m$prime) {
      return Curry._2(M[/* >>= */0], m, (function (v) {
                    return Curry._2(M[/* >>= */0], m$prime, (function (v$prime) {
                                  return Curry._1(M[/* pure */1], /* :: */[
                                              v,
                                              v$prime
                                            ]);
                                }));
                  }));
    };
    return Util_kernel.fold_right(k, l, Curry._1(M[/* pure */1], /* [] */0));
  };
  var sequence_ = function (l) {
    return Util_kernel.fold_right($great$great, l, Curry._1(M[/* pure */1], /* () */0));
  };
  var mapM = function (f, l) {
    return sequence(Util_kernel.map(f, l));
  };
  var mapM_ = function (f, l) {
    return sequence_(Util_kernel.map(f, l));
  };
  return /* module */[
          /* >> */$great$great,
          /* =<< */$eq$less$less,
          /* map */map,
          /* <$> */map,
          /* ap */ap,
          /* <-> */ap,
          /* sequence */sequence,
          /* sequence_ */sequence_,
          /* mapM */mapM,
          /* mapM_ */mapM_
        ];
}

function Monad_plus_make(M) {
  var msum = function (l) {
    return Util_kernel.fold_left(M[/* mplus */3], M[/* mzero */2], l);
  };
  var filter = function (f, m) {
    return Curry._2(M[/* >>= */0], m, (function (v) {
                  var match = Curry._1(f, v);
                  if (match !== 0) {
                    return Curry._1(M[/* pure */1], v);
                  } else {
                    return M[/* mzero */2];
                  }
                }));
  };
  return /* module */[
          /* msum */msum,
          /* filter */filter
        ];
}

function $great$great$eq(v, f) {
  if (v) {
    return Curry._1(f, v[0]);
  } else {
    return /* None */0;
  }
}

function pure(x) {
  return /* Some */[x];
}

function mplus(mx, my) {
  if (mx) {
    return mx;
  } else {
    return my;
  }
}

var Base = /* module */[
  /* >>= */$great$great$eq,
  /* pure */pure,
  /* mzero : None */0,
  /* mplus */mplus
];

function $great$great(a, b) {
  return $great$great$eq(a, (function () {
                return b;
              }));
}

function $eq$less$less(f, v) {
  return $great$great$eq(v, f);
}

function map(f, mx) {
  return $great$great$eq(mx, (function (x) {
                return /* Some */[Curry._1(f, x)];
              }));
}

function ap(mf, mx) {
  return $great$great$eq(mf, (function (param) {
                return Util_kernel.flip(map, mx, param);
              }));
}

function sequence(l) {
  var k = function (m, m$prime) {
    return $great$great$eq(m, (function (v) {
                  return $great$great$eq(m$prime, (function (v$prime) {
                                return /* Some */[/* :: */[
                                          v,
                                          v$prime
                                        ]];
                              }));
                }));
  };
  return Util_kernel.fold_right(k, l, /* Some */[/* [] */0]);
}

function sequence_(l) {
  return Util_kernel.fold_right($great$great, l, /* Some */[/* () */0]);
}

function mapM(f, l) {
  return sequence(Util_kernel.map(f, l));
}

function mapM_(f, l) {
  return sequence_(Util_kernel.map(f, l));
}

function msum(l) {
  return Util_kernel.fold_left(mplus, /* None */0, l);
}

function filter(f, m) {
  return $great$great$eq(m, (function (v) {
                var match = Curry._1(f, v);
                if (match !== 0) {
                  return /* Some */[v];
                } else {
                  return /* None */0;
                }
              }));
}

var Option = /* module */[
  /* Base */Base,
  /* >>= */$great$great$eq,
  /* pure */pure,
  /* mzero : None */0,
  /* mplus */mplus,
  /* >> */$great$great,
  /* =<< */$eq$less$less,
  /* map */map,
  /* <$> */map,
  /* ap */ap,
  /* <-> */ap,
  /* sequence */sequence,
  /* sequence_ */sequence_,
  /* mapM */mapM,
  /* mapM_ */mapM_,
  /* msum */msum,
  /* filter */filter
];

function $great$great$eq$1(l, f) {
  return List.concat(List.map(f, l));
}

function pure$1(v) {
  return /* :: */[
          v,
          /* [] */0
        ];
}

var Base$1 = /* module */[
  /* >>= */$great$great$eq$1,
  /* pure */pure$1,
  /* mzero : [] */0,
  /* mplus */Pervasives.$at
];

function $great$great$1(a, b) {
  return List.concat(List.map((function () {
                    return b;
                  }), a));
}

function $eq$less$less$1(f, v) {
  return List.concat(List.map(f, v));
}

function map$1(f, mx) {
  return List.concat(List.map((function (x) {
                    return /* :: */[
                            Curry._1(f, x),
                            /* [] */0
                          ];
                  }), mx));
}

function ap$1(mf, mx) {
  return List.concat(List.map((function (param) {
                    return Util_kernel.flip(map$1, mx, param);
                  }), mf));
}

function sequence$1(l) {
  var k = function (m, m$prime) {
    return List.concat(List.map((function (v) {
                      return List.concat(List.map((function (v$prime) {
                                        return /* :: */[
                                                /* :: */[
                                                  v,
                                                  v$prime
                                                ],
                                                /* [] */0
                                              ];
                                      }), m$prime));
                    }), m));
  };
  return Util_kernel.fold_right(k, l, /* :: */[
              /* [] */0,
              /* [] */0
            ]);
}

function sequence_$1(l) {
  return Util_kernel.fold_right($great$great$1, l, /* :: */[
              /* () */0,
              /* [] */0
            ]);
}

function mapM$1(f, l) {
  return sequence$1(Util_kernel.map(f, l));
}

function mapM_$1(f, l) {
  return sequence_$1(Util_kernel.map(f, l));
}

function msum$1(l) {
  return Util_kernel.fold_left(Pervasives.$at, /* [] */0, l);
}

function filter$1(f, m) {
  return List.concat(List.map((function (v) {
                    var match = Curry._1(f, v);
                    if (match !== 0) {
                      return /* :: */[
                              v,
                              /* [] */0
                            ];
                    } else {
                      return /* [] */0;
                    }
                  }), m));
}

var List$1 = /* module */[
  /* Base */Base$1,
  /* >>= */$great$great$eq$1,
  /* pure */pure$1,
  /* mzero : [] */0,
  /* mplus */Pervasives.$at,
  /* >> */$great$great$1,
  /* =<< */$eq$less$less$1,
  /* map */map$1,
  /* <$> */map$1,
  /* ap */ap$1,
  /* <-> */ap$1,
  /* sequence */sequence$1,
  /* sequence_ */sequence_$1,
  /* mapM */mapM$1,
  /* mapM_ */mapM_$1,
  /* msum */msum$1,
  /* filter */filter$1
];

exports.Monad_make      = Monad_make;
exports.Monad_plus_make = Monad_plus_make;
exports.Option          = Option;
exports.List            = List$1;
/* No side effect */
