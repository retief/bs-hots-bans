// Generated by BUCKLESCRIPT VERSION 1.7.5, PLEASE EDIT WITH CARE
'use strict';

var Curry                   = require("bs-platform/lib/js/curry.js");
var Util_monad              = require("./util_monad.js");
var Util_kernel             = require("./util_kernel.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function $great$great$eq(v, f) {
  if (v) {
    return Curry._1(f, v[0]);
  } else {
    return /* None */0;
  }
}

function pure(x) {
  return /* Some */[x];
}

function mplus(mx, my) {
  if (mx) {
    return mx;
  } else {
    return my;
  }
}

var Base = /* module */[
  /* >>= */$great$great$eq,
  /* pure */pure,
  /* mzero : None */0,
  /* mplus */mplus,
  /* map_impl : Define_using_bind */-349054340
];

var include = Util_monad.Monad_make([
      $great$great$eq,
      pure,
      /* Define_using_bind */-349054340
    ]);

var include$1 = Util_monad.Monad_plus_make([
      $great$great$eq,
      pure,
      /* Define_using_bind */-349054340,
      /* None */0,
      mplus
    ]);

function map_default(a, f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return Curry._1(f, a);
  }
}

function is_some(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_none(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function unwrap_exn(param) {
  if (param) {
    return param[0];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Can't unwrap None"
        ];
  }
}

function unwrap($$default, param) {
  if (param) {
    return param[0];
  } else {
    return $$default;
  }
}

function cons_maybe(m, l) {
  if (m) {
    return /* :: */[
            m[0],
            l
          ];
  } else {
    return l;
  }
}

function concat(l) {
  return Util_kernel.fold_right(cons_maybe, l, /* [] */0);
}

function map_concat(f, l) {
  var l$1 = Util_kernel.map(f, l);
  return Util_kernel.fold_right(cons_maybe, l$1, /* [] */0);
}

var mzero = /* None */0;

var map_impl = /* Define_using_bind */-349054340;

var bind = include[0];

var $great$great = include[1];

var $eq$less$less = include[2];

var map = include[3];

var $less$$great = include[4];

var $pipe$$great = include[5];

var ap = include[6];

var $less$neg$great = include[7];

var $pipe$neg$great = include[8];

var sequence = include[9];

var sequence_ = include[10];

var mapM = include[11];

var mapM_ = include[12];

var msum = include$1[0];

var filter = include$1[1];

exports.Base            = Base;
exports.$great$great$eq = $great$great$eq;
exports.pure            = pure;
exports.mzero           = mzero;
exports.mplus           = mplus;
exports.map_impl        = map_impl;
exports.bind            = bind;
exports.$great$great    = $great$great;
exports.$eq$less$less   = $eq$less$less;
exports.map             = map;
exports.$less$$great    = $less$$great;
exports.$pipe$$great    = $pipe$$great;
exports.ap              = ap;
exports.$less$neg$great = $less$neg$great;
exports.$pipe$neg$great = $pipe$neg$great;
exports.sequence        = sequence;
exports.sequence_       = sequence_;
exports.mapM            = mapM;
exports.mapM_           = mapM_;
exports.msum            = msum;
exports.filter          = filter;
exports.map_default     = map_default;
exports.is_some         = is_some;
exports.is_none         = is_none;
exports.unwrap_exn      = unwrap_exn;
exports.unwrap          = unwrap;
exports.cons_maybe      = cons_maybe;
exports.concat          = concat;
exports.map_concat      = map_concat;
/* include Not a pure module */
