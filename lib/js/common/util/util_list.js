// Generated by BUCKLESCRIPT VERSION 1.7.5, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Util_monad  = require("./util_monad.js");
var Util_kernel = require("./util_kernel.js");

function hd(param) {
  if (param) {
    return /* Some */[param[0]];
  } else {
    return /* None */0;
  }
}

function tl(param) {
  if (param) {
    return /* Some */[param[1]];
  } else {
    return /* None */0;
  }
}

function nth(t, n) {
  if (n < 0) {
    return /* None */0;
  } else {
    var _t = t;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var t$1 = _t;
      if (t$1) {
        var match = +(n$1 === 0);
        if (match !== 0) {
          return /* Some */[t$1[0]];
        } else {
          _n = n$1 - 1 | 0;
          _t = t$1[1];
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  }
}

function slow_append(l, l$prime) {
  return List.rev_append(List.rev(l), l$prime);
}

function count_append(l, l$prime, count) {
  if (l$prime) {
    if (l) {
      var match = l[1];
      var v1 = l[0];
      if (match) {
        var match$1 = match[1];
        var v2 = match[0];
        if (match$1) {
          var match$2 = match$1[1];
          var v3 = match$1[0];
          if (match$2) {
            var match$3 = match$2[1];
            var v4 = match$2[0];
            if (match$3) {
              var tl = match$3[1];
              var v5 = match$3[0];
              if (tl) {
                var match$4 = +(count > Util_kernel.stack_max);
                return /* :: */[
                        v1,
                        /* :: */[
                          v2,
                          /* :: */[
                            v3,
                            /* :: */[
                              v4,
                              /* :: */[
                                v5,
                                match$4 !== 0 ? List.rev_append(List.rev(tl), l$prime) : count_append(tl, l$prime, count + 1 | 0)
                              ]
                            ]
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        v1,
                        /* :: */[
                          v2,
                          /* :: */[
                            v3,
                            /* :: */[
                              v4,
                              /* :: */[
                                v5,
                                l$prime
                              ]
                            ]
                          ]
                        ]
                      ];
              }
            } else {
              return /* :: */[
                      v1,
                      /* :: */[
                        v2,
                        /* :: */[
                          v3,
                          /* :: */[
                            v4,
                            l$prime
                          ]
                        ]
                      ]
                    ];
            }
          } else {
            return /* :: */[
                    v1,
                    /* :: */[
                      v2,
                      /* :: */[
                        v3,
                        l$prime
                      ]
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  v1,
                  /* :: */[
                    v2,
                    l$prime
                  ]
                ];
        }
      } else {
        return /* :: */[
                v1,
                l$prime
              ];
      }
    } else {
      return l$prime;
    }
  } else {
    return l;
  }
}

function append(l, l$prime) {
  return count_append(l, l$prime, 0);
}

function concat(l) {
  return Util_kernel.fold_right(append, l, /* [] */0);
}

function map_concat(f, l) {
  return Util_kernel.fold_right(append, Util_kernel.map(f, l), /* [] */0);
}

function $great$great$eq(l, f) {
  return Util_kernel.fold_right(append, Util_kernel.map(f, l), /* [] */0);
}

function pure(v) {
  return /* :: */[
          v,
          /* [] */0
        ];
}

var map_impl = /* `Custom */[
  -198771759,
  Util_kernel.map
];

var Monad_base = /* module */[
  /* >>= */$great$great$eq,
  /* pure */pure,
  /* mzero : [] */0,
  /* mplus */append,
  /* map_impl */map_impl
];

var include = Util_monad.Monad_make([
      $great$great$eq,
      pure,
      map_impl
    ]);

var include$1 = Util_monad.Monad_plus_make([
      $great$great$eq,
      pure,
      map_impl,
      /* [] */0,
      append
    ]);

function slow_filter(p, _l, _acc) {
  while(true) {
    var acc = _acc;
    var l = _l;
    if (l) {
      var tl = l[1];
      var v = l[0];
      var match = Curry._1(p, v);
      if (match !== 0) {
        _acc = /* :: */[
          v,
          acc
        ];
        _l = tl;
        continue ;
        
      } else {
        _l = tl;
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function count_filter(i, p, _l) {
  while(true) {
    var l = _l;
    if (l) {
      if (i > Util_kernel.stack_max) {
        return List.rev(slow_filter(p, l, /* [] */0));
      } else {
        var tl = l[1];
        var v = l[0];
        var match = Curry._1(p, v);
        if (match !== 0) {
          return /* :: */[
                  v,
                  count_filter(i + 1 | 0, p, tl)
                ];
        } else {
          _l = tl;
          continue ;
          
        }
      }
    } else {
      return /* [] */0;
    }
  };
}

function filter(p, l) {
  return count_filter(0, p, l);
}

function rev_mapi(f, l) {
  var _i = 0;
  var _res = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var res = _res;
    var i = _i;
    if (param) {
      _param = param[1];
      _res = /* :: */[
        Curry._2(f, i, param[0]),
        res
      ];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return res;
    }
  };
}

function mapi(f, l) {
  return List.rev(rev_mapi(f, l));
}

function map2(f, l1, l2) {
  return List.rev(List.rev_map2(f, l1, l2));
}

function fold_right2(f, l1, l2, accu) {
  return List.fold_left2((function (a, b, c) {
                return Curry._3(f, b, c, a);
              }), accu, List.rev(l1), List.rev(l2));
}

function replicate(n, v) {
  var _i = n;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    var match = +(i <= 0);
    if (match !== 0) {
      return res;
    } else {
      _res = /* :: */[
        v,
        res
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function some_option(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var v$prime = Curry._1(f, param[0]);
      if (v$prime) {
        return v$prime;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function some(f, l) {
  var mapper = function (v$prime) {
    var match = Curry._1(f, v$prime);
    if (match !== 0) {
      return /* Some */[v$prime];
    } else {
      return /* None */0;
    }
  };
  var match = some_option(mapper, l);
  if (match) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function all(f, l) {
  return 1 - some((function (v) {
                return 1 - Curry._1(f, v);
              }), l);
}

function merge(cmp, l1, l2) {
  var _acc = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var acc = _acc;
    if (l1$1) {
      if (l2$1) {
        var h2 = l2$1[0];
        var h1 = l1$1[0];
        var match = +(Curry._2(cmp, h1, h2) <= 0);
        if (match !== 0) {
          _l1 = l1$1[1];
          _acc = /* :: */[
            h1,
            acc
          ];
          continue ;
          
        } else {
          _l2 = l2$1[1];
          _acc = /* :: */[
            h2,
            acc
          ];
          continue ;
          
        }
      } else {
        return List.rev_append(acc, l1$1);
      }
    } else {
      return List.rev_append(acc, l2$1);
    }
  };
}

function range($staropt$star, stop) {
  var start = $staropt$star ? $staropt$star[0] : 0;
  if (start >= stop) {
    return /* [] */0;
  } else {
    var _n = stop - 1 | 0;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var n = _n;
      var match = +(n < start);
      if (match !== 0) {
        return accu;
      } else {
        _accu = /* :: */[
          n,
          accu
        ];
        _n = n - 1 | 0;
        continue ;
        
      }
    };
  }
}

var length = List.length;

var rev = List.rev;

var rev_append = List.rev_append;

var flatten = List.flatten;

var iter = List.iter;

var iteri = List.iteri;

var rev_map = List.rev_map;

var fold_left = List.fold_left;

var iter2 = List.iter2;

var rev_map2 = List.rev_map2;

var fold_left2 = List.fold_left2;

var for_all = List.for_all;

var exists = List.exists;

var for_all2 = List.for_all2;

var exists2 = List.exists2;

var mem = List.mem;

var memq = List.memq;

var find = List.find;

var find_all = List.find_all;

var partition = List.partition;

var assoc = List.assoc;

var assq = List.assq;

var mem_assoc = List.mem_assoc;

var mem_assq = List.mem_assq;

var remove_assoc = List.remove_assoc;

var remove_assq = List.remove_assq;

var split = List.split;

var combine = List.combine;

var sort = List.sort;

var stable_sort = List.stable_sort;

var fast_sort = List.fast_sort;

var sort_uniq = List.sort_uniq;

var stack_max = Util_kernel.stack_max;

var $at = append;

var slow_map = Util_kernel.slow_map;

var count_map = Util_kernel.count_map;

var fold_right = Util_kernel.fold_right;

var mzero = /* [] */0;

var mplus = append;

var bind = include[0];

var $great$great = include[1];

var $eq$less$less = include[2];

var map = include[3];

var $less$$great = include[4];

var $pipe$$great = include[5];

var ap = include[6];

var $less$star$great = include[7];

var $pipe$star$great = include[8];

var sequence = include[9];

var sequence_ = include[10];

var mapM = include[11];

var mapM_ = include[12];

var msum = include$1[0];

exports.length           = length;
exports.rev              = rev;
exports.rev_append       = rev_append;
exports.flatten          = flatten;
exports.iter             = iter;
exports.iteri            = iteri;
exports.rev_map          = rev_map;
exports.fold_left        = fold_left;
exports.iter2            = iter2;
exports.rev_map2         = rev_map2;
exports.fold_left2       = fold_left2;
exports.for_all          = for_all;
exports.exists           = exists;
exports.for_all2         = for_all2;
exports.exists2          = exists2;
exports.mem              = mem;
exports.memq             = memq;
exports.find             = find;
exports.find_all         = find_all;
exports.partition        = partition;
exports.assoc            = assoc;
exports.assq             = assq;
exports.mem_assoc        = mem_assoc;
exports.mem_assq         = mem_assq;
exports.remove_assoc     = remove_assoc;
exports.remove_assq      = remove_assq;
exports.split            = split;
exports.combine          = combine;
exports.sort             = sort;
exports.stable_sort      = stable_sort;
exports.fast_sort        = fast_sort;
exports.sort_uniq        = sort_uniq;
exports.hd               = hd;
exports.tl               = tl;
exports.nth              = nth;
exports.stack_max        = stack_max;
exports.slow_append      = slow_append;
exports.count_append     = count_append;
exports.append           = append;
exports.$at              = $at;
exports.slow_map         = slow_map;
exports.count_map        = count_map;
exports.fold_right       = fold_right;
exports.concat           = concat;
exports.map_concat       = map_concat;
exports.Monad_base       = Monad_base;
exports.$great$great$eq  = $great$great$eq;
exports.pure             = pure;
exports.mzero            = mzero;
exports.mplus            = mplus;
exports.map_impl         = map_impl;
exports.bind             = bind;
exports.$great$great     = $great$great;
exports.$eq$less$less    = $eq$less$less;
exports.map              = map;
exports.$less$$great     = $less$$great;
exports.$pipe$$great     = $pipe$$great;
exports.ap               = ap;
exports.$less$star$great = $less$star$great;
exports.$pipe$star$great = $pipe$star$great;
exports.sequence         = sequence;
exports.sequence_        = sequence_;
exports.mapM             = mapM;
exports.mapM_            = mapM_;
exports.msum             = msum;
exports.slow_filter      = slow_filter;
exports.count_filter     = count_filter;
exports.filter           = filter;
exports.rev_mapi         = rev_mapi;
exports.mapi             = mapi;
exports.map2             = map2;
exports.fold_right2      = fold_right2;
exports.replicate        = replicate;
exports.some_option      = some_option;
exports.some             = some;
exports.all              = all;
exports.merge            = merge;
exports.range            = range;
/* include Not a pure module */
