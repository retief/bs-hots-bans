// Generated by BUCKLESCRIPT VERSION 1.7.5, PLEASE EDIT WITH CARE
'use strict';

var Curry       = require("bs-platform/lib/js/curry.js");
var Util_kernel = require("./util_kernel.js");

function Monad_make(M) {
  var bind = M[/* >>= */0];
  var $great$great = function (a, b) {
    return Curry._2(M[/* >>= */0], a, (function () {
                  return b;
                }));
  };
  var $eq$less$less = function (f, v) {
    return Curry._2(M[/* >>= */0], v, f);
  };
  var match = M[/* map_impl */2];
  var map = typeof match === "number" ? (function (f, mx) {
        return Curry._2(M[/* >>= */0], mx, (function (x) {
                      return Curry._1(M[/* pure */1], Curry._1(f, x));
                    }));
      }) : match[1];
  var $pipe$$great = function (v, f) {
    return Curry._2(map, f, v);
  };
  var ap = function (mf, mx) {
    return Curry._2(M[/* >>= */0], mf, (function (param) {
                  return Util_kernel.flip(map, mx, param);
                }));
  };
  var $pipe$neg$great = function (v, f) {
    return ap(f, v);
  };
  var sequence = function (l) {
    var k = function (m, m$prime) {
      return Curry._2(M[/* >>= */0], m, (function (v) {
                    return Curry._2(M[/* >>= */0], m$prime, (function (v$prime) {
                                  return Curry._1(M[/* pure */1], /* :: */[
                                              v,
                                              v$prime
                                            ]);
                                }));
                  }));
    };
    return Util_kernel.fold_right(k, l, Curry._1(M[/* pure */1], /* [] */0));
  };
  var sequence_ = function (l) {
    return Util_kernel.fold_right($great$great, l, Curry._1(M[/* pure */1], /* () */0));
  };
  var mapM = function (f, l) {
    return sequence(Util_kernel.map(f, l));
  };
  var mapM_ = function (f, l) {
    return sequence_(Util_kernel.map(f, l));
  };
  return /* module */[
          /* bind */bind,
          /* >> */$great$great,
          /* =<< */$eq$less$less,
          /* map */map,
          /* <$> */map,
          /* |$> */$pipe$$great,
          /* ap */ap,
          /* <-> */ap,
          /* |-> */$pipe$neg$great,
          /* sequence */sequence,
          /* sequence_ */sequence_,
          /* mapM */mapM,
          /* mapM_ */mapM_
        ];
}

function Monad_plus_make(M) {
  var msum = function (l) {
    return Util_kernel.fold_left(M[/* mplus */4], M[/* mzero */3], l);
  };
  var filter = function (f, m) {
    return Curry._2(M[/* >>= */0], m, (function (v) {
                  var match = Curry._1(f, v);
                  if (match !== 0) {
                    return Curry._1(M[/* pure */1], v);
                  } else {
                    return M[/* mzero */3];
                  }
                }));
  };
  return /* module */[
          /* msum */msum,
          /* filter */filter
        ];
}

exports.Monad_make      = Monad_make;
exports.Monad_plus_make = Monad_plus_make;
/* No side effect */
